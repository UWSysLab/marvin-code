#!/usr/bin/perl

# This script takes as input files generated by record-working-set-data.pl.
# It outputs a few different values:
#     * The max and min read working set values observed during the "active
#       foreground" period after 30 seconds.
#     * The last read working set value observed during the "idle foreground"
#       period.
#     * The last read working set value observed during the "background"
#       period.
# It also outputs a warning if there are not exactly two "SEMISPACE" rows in
# the input file, or if there are any working set rows after the second
# "SEMISPACE" row. This warning is because we assume that data collection ended
# right after the second semi-space GC, and that the last working set values in
# the file are therefore the correct working set values for the "background"
# period.

use warnings;
use strict;

my $usage = "usage: ./process-working-set-data.pl app1 file1 app2 file2 ...";
die "$usage\n" if @ARGV < 2;

my @apps = ();
my @files = ();

for (my $i = 0; $i < @ARGV; $i += 2) {
    push(@apps, $ARGV[$i]);
    push(@files, $ARGV[$i + 1]);
}

print("Value,App,Type\n");

for (my $i = 0; $i < @apps; $i++) {
    my $app = $apps[$i];
    my $file = $files[$i];
    open(FILE, $file);

    my $PHASE_ACTIVE_FG = 0;
    my $PHASE_IDLE_FG = 1;
    my $PHASE_BG = 2;

    my $activeFgReadMax = 0;
    my $activeFgReadMin = 1e20;
    my $idleFgReadVal = 0;
    my $bgReadVal = 0;

    my $phase = $PHASE_ACTIVE_FG;
    my $semiSpaceCount = 0;

    while(<FILE>) {
        if ($_ =~ /Idle foreground/) {
            $phase = $PHASE_IDLE_FG;
        }
        elsif ($_ =~ /Background/) {
            $phase = $PHASE_BG;
        }
        elsif ($_ =~ /^(\S+),(\S+),(\S+)$/) {
            my $time = $1;
            my $val = $2;
            my $type = $3;

            if ($semiSpaceCount >= 2) {
                print(STDERR "Error: data detected after second semispace GC.");
            }

            if ($type eq "READ") {
                if ($phase == $PHASE_ACTIVE_FG) {
                    if ($time > 30) {
                        if ($val < $activeFgReadMin) {
                            $activeFgReadMin = $val;
                        }
                        if ($val > $activeFgReadMax) {
                            $activeFgReadMax = $val;
                        }
                    }
                }
                elsif ($phase == $PHASE_IDLE_FG) {
                    $idleFgReadVal = $val;
                }
                elsif ($phase == $PHASE_BG) {
                    $bgReadVal = $val;
                }
            }
            elsif ($type eq "SEMISPACE") {
                $semiSpaceCount++;
            }
        }
    }
    close(FILE);

    print("$activeFgReadMax,$app,active_fg_read_max\n");
    print("$activeFgReadMin,$app,active_fg_read_min\n");
    print("$idleFgReadVal,$app,idle_fg_read\n");
    print("$bgReadVal,$app,bg_read\n");
}
